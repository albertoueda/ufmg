\documentclass[a4paper,12pt,titlepage]{article}
%\usepackage[T1]{fontenc}

\usepackage{titlesec}
\usepackage{titling}
\usepackage[portuguese]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
%\usepackage{times}
\usepackage{ucs}
\usepackage{float}    
\usepackage{fancyvrb}   
\usepackage{verbatim}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{epigraph}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{lipsum}
\usepackage{amsfonts}

\hypersetup{
    colorlinks=true,       
    linkcolor=black,          
    citecolor=black,   
    filecolor=black,  
    urlcolor=black  
}

\hyphenation {di-re-cio-na-men-to} 

%\renewcommand*{\familydefault}{\ttdefault}
\lstset{columns=fullflexible,basicstyle=\ttfamily}

\title{\large
Universidade Federal de Minas Gerais \\ \
Instituto de Ciências Exatas \\ \ 
Departamento de Ciência da Computação \\ \
\\[1cm]
Projeto e Análise de Algoritmos\\ \
Trabalho Prático 1\\ \
\\[1cm]
\textbf{\Large Orkato}
\\[1cm]
}

\author{\large Alberto Hideki Ueda \\[0.5cm] 
Matrícula: 2014765817
\\[3cm] }

\date{\textsc{Belo Horizonte\\ \
9 de outubro de 2014}}

\begin{document}
\maketitle

\pagebreak

\section{Introdução}
Dado um conjunto de amigos, deseja-se descobrir qual é a melhor configuração possível entre todas as possibilidades de unir todos os amigos em uma única rede. Para cada amizade entre duas pessoas, são fornecidas duas informações: o \textit{nível} da amizade e a \textit{distância} física entre elas. Define-se a qualidade de uma configuração a divisão da soma de todos os valores de amizade desta configuração pela soma de todas as distâncias. Em outras palavras, deseja-se a configuração de amizades de maior qualidade possível.

\section{Modelagem}
Seja cada indivíduo um vértice e cada amizade entre duas pessoas uma aresta ligando dois vértices, podemos definir o conjunto de amigos original como um grafo $G$ contendo todas as amizades possíveis de acordo com o conjunto fornecido. Deste modo, cada configuração de amizades pode ser vista como um possível \textit{subgrafo} de $G$. 

Considerando a restrição de que uma configuração viável deve alcançar todos as pessoas do conjunto, é natural considerar como subgrafos válidos apenas os que conectam todos os vértices do grafo original $G$. Assim, caso não seja possível conectar todos os amigos, o valor da função qualidade para todo subgrafo possível não é definido e consequentemente o problema não tem solução. Neste caso, seguindo a especificação do trabalho, o algoritmo implementado devolve um valor pré-estabelecido.

A grande peculiaridade deste problema é que o \textit{peso} de uma aresta não pode ser simplesmente a) o nível de amizade, b) a distância, ou c) a divisão da amizade pela distância, pois nestes casos o algoritmo descartará informações relevantes. Por exemplo, se for utilizada a divisão amizade/distância como peso da aresta, amizades como (2000/1000) e (2/1) serão consideradas equivalentes, o que não é verdadeiro, dada a função de qualidade.

Porém, se nível de amizade e distância forem considerados separadamente, a única solução conhecida para maximizar a qualidade seria utilizar algoritmos de força-bruta, testando configuração por configuração. Sendo $E$ o número de arestas no grafo original $G$, o número de subgrafos possíveis é da ordem de $2^E$ e o algoritmo teria complexidade exponencial. 

Felizmente, podemos adotar o custo de cada aresta $i$ como $f_i - (d_i * r)$, onde $f$ e $d$ são os valores do nível da amizade e da distância, respectivamente. e $r$ um candidato ao valor da qualidade ótima do subgrafo. Tal atribuição vem diretamente da definição da função de qualidade.

Seja $r$ a qualidade de um subgrafo. Temos que:

$ r = (f_1 + f_2 + ... + f_n)  /  (d_1 + d_2 + ... + d_n) => $
\ \\  

$ (f_1 - (d_1 * r)) + (f_2 - (d_2 * r)) + ... + (f_n - (d_n * r)) = 0 $
\ \\ 

Podemos então adotar tal peso para as arestas e solucionar o problema buscando o valor de $r$ que satisfaça a equação, conforme descrito a seguir.

\section{Breve Descrição da Solução}

Dado um grafo $G$ não-direcionado, verificamos primeiramente se ele é conectado (i.e. se há caminhos entre todos os vértices de $G$). Caso não seja, paramos a execução e informamos que ele não é conectado. Caso contrário, definimos dois limitantes - um inferior e um superior - para escolher um candidato $r_{cand}$ à qualidade ótima. Calculamos então a árvore espalhadora máxima de $G$, baseando-se nos pesos calculados com o valor de $r_{cand}$. Em seguida, adicionamos à árvore todas as arestas que \textit{aumentam} a qualidade do subgrafo. Verificamos então se o somatório de todos os pesos equivale a zero, conforme equação da seção anterior. Em caso positivo, $r_{cand}$ é o valor ótimo para qualidade de $G$ e o programa é finalizado. Em caso negativo, atualizamos ou o limitante superior ou o inferior, dependendo do valor resultante da soma dos pesos. Definimos em seguida um novo $r_{cand}$ (seguindo em uma busca binária para o $r_{cand}$ ótimo), recalculamos todos os pesos das arestas repetindo o processo.

\section{Etapas da Solução}

\begin{enumerate}
\item\textbf{Verificação de grafo conectado} \\
a
\item\textbf{Escolha do candidato à qualidade ótima} \\
b
\item\textbf{Cálculo da Árvore Espalhadora Máxima} \\
b
\item\textbf{Adição de arestas que aumentam a qualidade} \\
b
\item\textbf{Atualização dos limitantes} \\
b
\item\textbf{Condições de parada} \\
b
figura

\end{enumerate}

\section{Dificuldades Encontradas}

\begin{itemize}
\item {Suporte às arestas duplicadas:} como apresentadas no grafo do terceiro exemplo do enunciado do TP, assim como no terceiro do arquivo $test.in$ disponibilizado no Moodle, algumas arestas poderiam estar duplicadas no grafo de entrada. Embora no fórum tenha sido dito que as chances disso acontecer na correção eram pequenas, a probabilidade positiva causou uma mudança considerável na implementação do programa no final do trabalho. Em um dado momento optei por substituir a estrutura de dados, de matriz a listas de adjacências, visando maior qualidade na modelagem e de código.

\item {Cálculo do peso/custo das arestas:} sem o auxílio do professor ou dos monitores seria bastante difícil encontrar a solução do problema.

\item {Linguagem C++:} já há algum tempo não programava com C ou C++ e a utilização de ponteiros mostrou-se desafiadora em alguns momentos. Porém serviu como uma ótima revisão. 

\end{itemize}

\section{Conclusão}

Apesar de ser um problema aparentemente muito difícil, a atribuição de pesos utilizada no trabalho o torna factível em tempo polinomial. O uso de algoritmos como o de Kruskal dentro de um laço com busca binária foi bastante interessante, assim como de visualizar o algoritmo "buscando" a melhor configuração de amizades possível.

Muitos erros foram encontrados e corrigidos ao decorrer da implementação, porém a maioria deles relacionados ao uso de ponteiros em C++, não aos algoritmos em si. Outro ponto a destacar foi o aumento do conhecimento em relação às estruturas de dados, que tiveram de ser substituídas durante a implementação do programa.

\cite{cormen} 

% Referências
\bibliographystyle{plain}%amsalpha
\bibliography{bibliografia}
\newpage

\end{document}


