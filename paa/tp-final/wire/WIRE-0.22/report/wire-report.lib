#!/usr/bin/perl

package WIRE;

$WIRE::GNUPLOT_OPTIONS = qq|set terminal postscript eps monochrome "Times-Roman" 24|;
@WIRE::REPORT_OBJECTS	= ();

use POSIX		();
use IO::File	();
use XML::LibXML	();
use warnings;
use strict;

########################################################################
#
# round()
# numformat()
#
# Functions for rounding and formatting numbers
#
########################################################################


sub round {
	my $num = $_[0];
	my $ceil	= POSIX::ceil($num);
	my $floor	= POSIX::floor($num);

	if( abs($ceil - $num) > abs($floor - $num) ) {
		return $floor;
	} else {
		return $ceil;
	}
}

sub numformat {
	my $text = $_[0];
	chomp $text;
	if( $text !~ /^[\d\+\-\.e]+$/ ) {
		if( $text !~ /\\_/ ) {
			$text =~ s/_/\\_/g;
		}
		return $text;
	}
	if( $text =~ /\./ ) {
		# Decimal places
		$text = sprintf( "%.2f", $text );
	}

	# Commas
	$text = reverse $text;
	$text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
	$text = scalar reverse $text;

	return $text;
}

########################################################################
#
# gnuplot()
#
# Function for generating graphs
# 
########################################################################

sub gnuplot {
	my %param = @_;
	my $out	= $param{out};
	my $outf	= new IO::File "> ${out}.gnuplot";
	print $outf qq|$WIRE::GNUPLOT_OPTIONS\n|;
	print $outf qq|set output "${out}.eps"\n|;
	print $outf qq|set xlabel "$param{xlabel}"\n|;
	print $outf qq|set ylabel "$param{ylabel}"\n|;
	
	$param{xtics}	||= 'autofreq';
	$param{ytics}	||= 'autofreq';
	print $outf qq|set xtics $param{xtics}\n|;
	print $outf qq|set ytics $param{ytics}\n|;

	if( $param{grid} ) {
		print $outf qq|set grid $param{grid}\n|;
	}

	$param{key}		||= 'top right';
	print $outf qq|set key $param{key}\n|;

	if( $param{fit} ) {

		# Default is fit the first and third column
		$param{fitusing}	||=	qq|(\$1):(\$1 >= fitmin && \$1 <= fitmax ? \$3 : 1/0) "%lf,%lf,%lf"|;

		# Default function
		$param{fitfunction}	||= qq|(a / (x ** b) )|;

		# Default start for 'b'
		$param{fitstart}	||= 2;

		# This speeds up the convergence, we start with
		# parameter '2' as it is common
		print $outf qq|b = $param{fitstart}\n|;
		print $outf qq|fit(x) = $param{fitfunction}\n|;
		print $outf qq|fitmin = $param{fitmin}\n|;
		print $outf qq|fitmax = $param{fitmax}\n|;
		print $outf qq|fit fit(x) "$param{datafile}" every ::1 using $param{fitusing} via a,b\n|;
		$outf->close();

		# Execute fit
		unlink( 'fit.log' );
		`gnuplot ${out}.gnuplot 2>&1`;
		$param{fit_b}	= `cat fit.log | grep '^b.*=.*+\/-' | tail -n 1 | awk -F' ' '{print \$3}'`;
		$param{fit_b}	= numformat( $param{fit_b} );

		$outf	= new IO::File ">> ${out}.gnuplot";
	}

	if( $param{logscale} ) {
		print $outf qq|set logscale $param{logscale}\n|;
	} else {
		print $outf qq|set nologscale\n|;
	}

	if( defined $param{xdata} && $param{xdata} eq 'time' ) {
		print $outf qq|set xdata $param{xdata}\n|;
	}

	if( defined $param{xformat} ) {
		print $outf qq|set format x $param{xformat}\n|;
	}
	if( defined $param{yformat} ) {
		print $outf qq|set format y $param{yformat}\n|;
	}

	print $outf qq|plot |;

	if( $param{range} ) {
		print $outf qq|$param{range} |;
	}

	my( @datafiles, @everys, @usings, @withs, @titles );
	if( ref($param{datafile}) eq 'ARRAY' ) {
		$param{every}	||= [];
		@datafiles	= @{$param{datafile}};
		@everys		= @{$param{every}};
		@usings		= @{$param{using}};
		@withs		= @{$param{with}};
		@titles		= @{$param{title}};
	} else {
		$param{every}	||= 1;
		@datafiles	= ( $param{datafile} );
		@everys		= ( $param{every} );
		@usings		= ( $param{using} );
		@withs		= ( $param{with} );
		@titles		= $param{title} ? ( $param{title} ) : ( "" );
	}
	
	while( my $datafile = shift @datafiles ) {
		my $every	= shift @everys;
		my $using	= shift @usings;
		my $with	= shift @withs;
		my $title	= shift @titles;

		# Plot
		print $outf qq|"${datafile}" |;

		$every	||= '1';
		print $outf qq|every $every |;

		print $outf qq|using ${using} |;

		print $outf qq|title "${title}" |;

		# With (lines/dots/points)
		if( ! $with || $with eq 'dots' || $with eq 'points' ) {
			$with	= 'points pt 7 ps 0.3';
		} elsif( $with eq 'linespoints' ) {
			$with	= $with . " pt 7 ps 0.5";
		}

		print $outf qq|with $with |;

		if( @datafiles ) { # I'm not the last item
			print $outf qq|,|;
		}
	}

	# Fit
	if( $param{fit} ) {
		$param{fitmsg}	||= 'k/x^';

		print $outf qq|, fit(x) title '$param{fitmsg}$param{fit_b} in [$param{fitmin},$param{fitmax}]' with lines|;
	}


	$outf->close();

	print STDERR "Plotting graph ${out} ... ";
	my $ok = `gnuplot ${out}.gnuplot 2>&1 > ${out}.log_gnuplot && echo "OK"`;
	if( $ok !~ /OK/ ) {
		print STDERR " *** Failed during ${out}.gnuplot *** \n";
		print STDERR " Please verify the settings in the configuration file\n";
		print STDERR " See ${out}.log_gnuplot for details\n\n";
		print STDERR $ok;
#		exit 1;
	}
	print STDERR "done.\n";

	# Generate latex code for the figure
	latex_figure( $out );
}

########################################################################
#
# load_data()
#
# Function for loading data tables in CSV format
# 
########################################################################

sub load_data {
	my $basename	= shift;
	my %opts		= @_;

	my $file		= new IO::File "< ${basename}.csv";
	$file or die( "Couldn't open ${basename}.csv for reading" );
	my $data		= [];
	my $total		= 0;
	my $fields		= 0;
	while(my $line = <$file>) {
		chomp( $line );

		my @line	= split( /,/, $line );

		# Parse lines
		if( $opts{parse_row} ) {
			@line	= &{$opts{parse_row}}( @line );	
			if( ! @line ) {
				# Skip if empty
				next;
			}
		}

		$line[0] =~ s/_/\\_/g;

		# Count fields
		$fields		= ( (scalar @line) + 1 ) if $. == 1;

		# Summarize total
		if( ! $opts{nopercent} ) {
			$total		+= $line[-2] if( $. > 1 );
		}


		# Create row
		if( $opts{add_repeated} ) {
			my $found = 0;
			foreach my $tuple ( @$data ) {
				if( $tuple->[0] eq $line[0] ) {
					$tuple->[1] += $line[1];
					$found = 1;
				}
			}
			if( ! $found ) {
				push( @$data, [ @line ] );
			}
		} else {
			push( @$data, [ @line ] );
		}

	}

	# Add one column: percent
	if( ! $opts{nopercent} ) {
		foreach my $row ( @$data ) {
			my $last	= $$row[-2];

			if( $last =~ /^\d+$/ ) {
				pop( @$row );
				push( @$row, round( $last * 10000 / $total ) / 100 );
			} else {
				pop( @$row );
				push( @$row, "Percent" );
			}
		}
	}

	return( $data, $total, $fields - 1 );
}

########################################################################
#
# latex_table()
#
# Function for generating tables in latex
# 
########################################################################

sub latex_table {
	my $basename		= shift;
	my %opts			= @_;

	my $input			= defined $opts{input} ? $opts{input} : $basename;

	print STDERR "Generating table $basename ... ";

	my $out				= new IO::File "> ${basename}_tab.tex";

	my( $data, $total, $fields ) = load_data( $input, %opts );

	my $colspec			= 'l|' . ( 'r|' x ($fields - 1) );
	$colspec			=~ s/\|$//g;

	if( $opts{longtable} ) {
		print $out "\\begin{longtable}{$colspec}\n";
	} else {
		print $out "\\begin{table}[htb]\n";
		print $out "\\begin{tabular}{$colspec}\n";
	}

	# Print header row
	my $firstrow		= shift @$data;
	print $out join( ' & ', map { WIRE::numformat($_) } @$firstrow ) . '\\\\ \\hline' . "\n";

	# Print other rows
	my @data_sorted;

	if( $opts{nosort} ) {
		@data_sorted	= @$data;
	} else {
		if( $fields == 3 ) {
			# Sort by last field
			@data_sorted	=  sort { $$b[-2] <=> $$a[-2] } @$data;
		} else {
			# Sort by previous to last field
			@data_sorted	=  sort { $$b[-1] <=> $$a[-1] } @$data;
		}
	}

	foreach my $row ( @data_sorted ) {

		if( defined $opts{maxcol1} ) {
			next if $$row[0] > $opts{maxcol1};
		}

		# Print row
		if( $opts{nonumformat} ) {
			if( $opts{nopercent} ) {
				print $out join( ' & ', map { $_ } @$row ) . ' \\\\' . "\n";
			} else {
				print $out join( ' & ', map { $_ } @$row ) . '\\% \\\\' . "\n";
			}
		} else {
			if( $opts{nopercent} ) {
				print $out join( ' & ', map { numformat($_) } @$row ) . ' \\\\' . "\n";
			} else {
				print $out join( ' & ', map { numformat($_) } @$row ) . '\\% \\\\' . "\n";
			}
		}

		if( defined $opts{cut} ) {
			last if --$opts{cut} == 0;
		}
	}

	if( ! $opts{longtable} ) {
		print $out "\\end{tabular}\n";
	}

	# Caption
	my $caption	= ucfirst( $basename );
	$caption =~ s/_/ /g;
	print $out "\\caption{$caption}\n";

	# Label
	my $label	= "tbl" . ucfirst($basename);
	$label 		=~ s/_//g;
	print $out "\\label{$label}\n";

	if( $opts{longtable} ) {
		print $out "\\end{longtable}\n";
	} else {
		print $out "\\end{table}\n";
	}

	$out->close();

	print STDERR "done.\n";

	push_report( $basename . '_tab' );
}

########################################################################
#
# latex_figure()
#
# Function for generating figures in latex
# 
########################################################################

sub latex_figure {
	my $basename	= shift;
	my $out	= new IO::File "> ${basename}_fig.tex";

	print $out "\\begin{figure}\n";
	print $out "\\begin{center}\n";
	print $out "\\includegraphics[width=6in,height=4.2in]{${basename}.eps}\n";
	my $label   = 'fig' . ucfirst($basename);
	$label =~ s/_//g;
	$label =~ s/\..*$//;
	print $out "\\label{$label}\n";

	my $caption	= ucfirst( $basename );
	$caption =~ s/_/ /g;
	print $out "\\caption{$caption}\n";
	print $out "\\end{center}\n";
	print $out "\\end{figure}\n";

	$out->close();

	push_report( $basename . '_fig' );
}

########################################################################
#
# latex_report()
#
# Function for generate the whole report
# 
########################################################################

sub latex_report {
	if( ! $ENV{WIRE_CONF} ) {
		die( "No WIRE_CONF variable found" );
	}
	
	my $code	= conf( 'analysis/code' );
	my $title	= $code . ' : ' . $WIRE::PART_NAME;
	$title		=~ s/_/\\_/g;

	my $out        = new IO::File "> ${WIRE::PART_NAME}.tex";
	print $out "\\documentclass{article}\n";
	print $out "\\usepackage{fullpage}\n";
	print $out "\\usepackage{graphicx}\n";
	print $out "\\usepackage{longtable}\n";
	print $out "\\begin{document}\n";

	print $out "\\title{$title}\n";
	print $out "\\maketitle\n";
	print $out "\\begin{verbatim}\n";
	my $host	= `hostname`; chomp $host;
	print $out "HOST=$host\n";
	print $out "BASE=$WIRE::BASE_DIR\n";
	print $out "CONF=$ENV{WIRE_CONF}\n";
	print $out "\\end{verbatim}\n";

	foreach my $basename ( @WIRE::REPORT_OBJECTS ) {
		print $out "\n\n";
		print $out "%" x 75;
		print $out "\n% ${basename}\n";
		print $out "%" x 75;
		print $out "\n\n";
		print $out `cat ${basename}.tex`;
		print $out "\\clearpage\n";
	}

	print $out "\\end{document}\n";

	$out->close();

	my $report_file	= "$WIRE::ANALYSIS_DIR/${code}-${WIRE::PART_NAME}.pdf";

	unlink $report_file;
	print STDERR "Typesetting ${WIRE::PART_NAME}.tex ... ";
	`latex -interaction=batchmode ${WIRE::PART_NAME}.tex && latex ${WIRE::PART_NAME}.tex && dvipdf ${WIRE::PART_NAME}.dvi $report_file 2>&1`;
	print STDERR "done.\n\n";

	if( ! -e $report_file ) { 
		print STDERR "Problems during latex, see ${WIRE::PART_NAME}.log file\n";
		print STDERR "Probably some graphs are missing.\n";
		print STDERR "Will try to generate a report anyways ...";
		print STDERR `dvipdf ${WIRE::PART_NAME}.dvi $report_file`;
		print STDERR " done.\n";
	}

	print STDERR "\n";
	print STDERR "Partial files in  : " . $WIRE::ANALYSIS_DIR . '/' . $WIRE::PART_NAME . "\n";
	print STDERR "Report written to : " . $WIRE::ANALYSIS_DIR . '/' . $code . '-' . ${WIRE::PART_NAME} . ".pdf" . "\n";

}

########################################################################
#
# select_rows()
#
########################################################################

sub select_rows {
	my %opts	= @_;
	$opts{datafile}	|| die( "No datafile" );
	$opts{outfile}	|| die( "No datafile" );

	my $label	= $opts{outfile};
		$label  =~ s/\..*$//;
	print STDERR "Processing data $label ... ";

	my @headers	= split( /,/, `head -n 1 $opts{datafile}` );

	# Get the number of the column
	my %colnum;
	my $headernum	= 0;
	foreach my $header ( @headers ) {
		$headernum ++;
		foreach my $colname ( @{$opts{colnames}} ) {
			if( $header =~ /^(\d*)$colname$/i ) {
				$colnum{$colname}	= $headernum;	
			}
			if( $colname =~ /^\d+$/ ) {
				$colnum{$colname}	= $colname;
			}
		}
	}

	my $sortdescindex	= 0;
	if( $opts{sortdesc} ) {
		my $colindex	= 0;
		foreach my $colname ( @{$opts{colnames}} ) {
			$colindex ++;
			if( lc($colname) eq lc($opts{sortdesc}) ) {
				$sortdescindex	= $colindex;
			}
			if( $colname =~ /^\d+$/ ) {
				$sortdescindex = $colname;
			}
		}

		if( $colindex == 0 ) {
			die( "Couldn't found $opts{sortdesc} in selected columns" );
		}
	}

	foreach my $colname ( @{$opts{colnames}} ) {
		# Check that I found them all
		if( ! $colnum{$colname} ) {
			die( "Couldn't found $colname in $opts{datafile}" );
		}
	}

	my $awk_options	= join( '","', map { '$' . $colnum{$_} } @{$opts{colnames}} );
	my $cut_options	= $opts{cut} ? "| head -n $opts{cut} " : "";

	$opts{header}	||= $opts{colnames};
	my $first_line	= join( ",", @{$opts{header}} );

	if( ! $opts{parse_row} ) {
		`echo "$first_line" > $opts{outfile}`;
	} else {
		`rm -f $opts{outfile}`;
	}

	my $command;
	if( $opts{sortdesc} ) {
		$command = "cat $opts{datafile} | tail -n +2 | awk -F, '{print $awk_options}'  | sort -gr -t, -k$sortdescindex $cut_options >> $opts{outfile}";
	} elsif( $opts{colnames} ) {
		$command = "cat $opts{datafile} | tail -n +2 | awk -F, '{print $awk_options}' $cut_options >> $opts{outfile}";
	} else {
		$command = "cat $opts{datafile} | tail -n +2 $cut_options >> $opts{outfile}";
	}

	# Execute
	`$command`;

	if( $opts{parse_row} ) {
		my $in = new IO::File "< $opts{outfile}";
		`rm -f tmp.$opts{outfile}`;
		`echo "$first_line" > tmp.$opts{outfile}`;
		my $out	= new IO::File ">> tmp.$opts{outfile}";

		while( my $line = <$in>) {
			last unless defined $line;

			chomp $line;
			my @line	= split( /,/, $line );
			die( "Problem with line '$line' while reading from $opts{outfile}" )
				unless @line;
			@line = &{$opts{parse_row}}( @line );
			if( length( $line[0] ) > 0 ) {
				print $out join( ",", @line ) . "\n";
			}
		}

		$in->close();
		$out->close();

		`mv tmp.$opts{outfile} $opts{outfile}`;
	}

	print STDERR "done.\n";

}

########################################################################
#
# all_pairs()
#
########################################################################

sub all_pairs {
	my @columns	= @_;
	my @result;

	for( my $i=0; $i<=$#columns; $i++ ) {
		for( my $j=$i+1; $j<=$#columns; $j++ ) {
			push( @result, $columns[$i], $i+1, $columns[$j], $j+1 );
		}
	}
	return @result;
}


########################################################################
#
# push_report()
#
########################################################################

sub push_report {
	my $basename	= shift;
	push( @WIRE::REPORT_OBJECTS, $basename );
}

########################################################################
#
# init()
#
# Clears all data about the report
#
########################################################################

$WIRE::CONF			= undef;
$WIRE::BASE_DIR		= undef;
$WIRE::ANALYSIS_DIR	= undef;
$WIRE::PART_NAME	= undef;

sub conf {
	my $expr	= shift;

	my $nodes	= $WIRE::CONF->findnodes( "/config/$expr/text()" );

	if( $nodes->size() == 0 ) {
		die( "/config/$expr/text() in $ENV{WIRE_CONF} doesn't exist" );
	} elsif( $nodes->size() == 1 ) {
		return $nodes->get_node(1)->textContent();
	} else {
		return map { $_->textContent() } $nodes->get_nodelist();
	}
}

sub init {
	$WIRE::PART_NAME	= shift;
	
	$ENV{WIRE_CONF}	or die( "No WIRE_CONF variable set" );

	my $parser			= XML::LibXML->new();
	$WIRE::CONF		= $parser->parse_file( $ENV{WIRE_CONF} );
	defined($WIRE::CONF) or die( "Couldn't read $ENV{WIRE_CONF} as XML" );

	
	$WIRE::BASE_DIR		= conf( 'collection/base' );
	$WIRE::ANALYSIS_DIR	= $WIRE::BASE_DIR . '/analysis';

	chdir( $WIRE::ANALYSIS_DIR . '/' . $WIRE::PART_NAME )
		or die( "Can't chdir to ${WIRE::ANALYSIS_DIR}/${WIRE::PART_NAME}: $!" );


	# Clean old files
	`mv -f *.tex *.aux *.log *.gnuplot *.eps tmp.* /tmp 2>&1 >/dev/null`;

	# Ensure 'Sort' works ok
	$ENV{LC_NUMERIC}	= 'C';
}

1;


